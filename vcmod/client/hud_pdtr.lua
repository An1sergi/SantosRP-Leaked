
-----------------------------------------------------
VC.Material.Reg = Material("sprites/light_ignorez") VC.Material.HD = Material("vcmod/lights/lines") VC.Material.HD2 = Material("vcmod/lights/lines_2") VC.Material.Glow = Material("vcmod/lights/glow_hd") VC.Material.Beam = Material("vcmod/lights/beam") VC.Material.HBeam = Material("vcmod/lights/hbeam")  function VC.Lerp_Points(int, Tbl) for k,v in pairs(Tbl) do local NDP = Tbl[k+1] if NDP and NDP[2] >= int then return LerpVector((NDP[2]-int)/(NDP[2]-v[2]), NDP[1], v[1]) end end end function VC.Bazzier(var, p1, p2, p3) return ((1-var)^2)*p1+2*(1-var)*(var)*p2+(var^2)*p3 end  local function Handle_Light_Init(Lhv, IsELS, col, SPos, Size)  if IsELS and Lhv[col][2] == 55 then if Lhv[col][1] == 255 and Lhv[col][3] == 0 then Lhv[col] = {255,0,0} elseif Lhv[col][1] == 0 and Lhv[col][3] == 255 then Lhv[col] = {0,0,255} end end  Lhv.SpecTable = nil local STSz = 0  if Lhv.SpecLine and Lhv.SpecLine.Use then  if !Lhv.SpecTable then Lhv.SpecTable = {} end  if Lhv.SpecLine.Amount and Lhv.SpecLine.Amount > 1 then local Am = Lhv.SpecLine.Amount-2 for i=1,Am do Lhv.SpecTable[i] = LerpVector(i/(Am+1), SPos, Lhv.SpecLine.Pos or Vector(0,0,0)) end STSz=STSz+Am end  local Cnt = table.Count(Lhv.SpecTable) Lhv.SpecTable[Cnt+1] = Lhv.Pos or Vector(0,0,0) Lhv.SpecTable[Cnt+2] = Lhv.SpecLine.Pos or Vector(0,0,0)  end   if Lhv.SpecMLine and Lhv.SpecMLine.Use and Lhv.SpecMLine.LTbl then  if !Lhv.SpecTable then Lhv.SpecTable = {Lhv.Pos} end Lhv.DrawingSpecMLine = true  local PT = {Lhv.Pos} local TotalDist = 0 local DistT = {{Lhv.Pos, 0}}  if Lhv.RenderBeam then Lhv.SpecTableBeam = {} Lhv.SpecTableBeam[1] = {Pos = Lhv.Pos, Size = 1} for k,v in pairs(Lhv.SpecMLine.LTbl) do if k == 1 then Lhv.SpecTableBeam[1] = {Pos = Lhv.Pos, Size = v.Size} if v.UseClr and v.Clr then Lhv.SpecTableBeam[1].Clr = Color(v.Clr[1], v.Clr[2], v.Clr[3]) end end Lhv.SpecTableBeam[k+1] = {Pos = v.Pos, Size = v.Size} if v.UseClr and v.Clr then Lhv.SpecTableBeam[k+1].Clr = Color(v.Clr[1], v.Clr[2], v.Clr[3]) end end end  if Lhv.SpecMLine.Amount and Lhv.SpecMLine.Amount > 0 then  for k,v in pairs(Lhv.SpecMLine.LTbl) do PT[k+1] = v.Pos end STSz=STSz+Lhv.SpecMLine.Amount-1  for k,v in pairs(PT) do if PT[k+1] then local TD = v:Distance(PT[k+1]) TotalDist=TotalDist+TD DistT[k+1] = {PT[k+1], TotalDist} else break end end  local Cnt = table.Count(Lhv.SpecTable) for i=1,Lhv.SpecMLine.Amount do Lhv.SpecTable[Cnt+i] = VC.Lerp_Points(TotalDist*(i/(Lhv.SpecMLine.Amount-1)), DistT) end  else  local LPos = SPos for k,v in pairs(Lhv.SpecMLine.LTbl) do local Cnt = table.Count(Lhv.SpecTable) local Am = (v.Amount or 2)-2 for i=1,Am do Lhv.SpecTable[Cnt+i] = LerpVector(i/(Am+1), LPos, v.Pos or Vector(0,0,0)) end Lhv.SpecTable[table.Count(Lhv.SpecTable)+1] = v.Pos PT[k+1] = v.Pos STSz=STSz+Am LPos = v.Pos end  end  end   if Lhv.SpecCircle and Lhv.SpecCircle.Use then  if Lhv.RenderBeam then Lhv.SpecTableBeam = {} end if !Lhv.SpecTable then Lhv.SpecTable = {} end  local Am, SAm = Lhv.SpecCircle.Amount or 3, table.Count(Lhv.SpecTable) for i=1,Am do local TVec = Vector(Lhv.SpecCircle.Radius or 1,0,0) TVec:Rotate(Angle(i/Am*360, 0, 0)) Lhv.SpecTable[SAm+i] = SPos+TVec if Lhv.RenderBeam then Lhv.SpecTableBeam[i] = {Pos = SPos+TVec} table.insert(Lhv.SpecTableBeam, {Pos = Lhv.SpecTableBeam[1].Pos}) end end STSz=STSz+Am  end   if Lhv.SpecRec and Lhv.SpecRec.Use then  if !Lhv.SpecTable then Lhv.SpecTable = {} end local SAm = table.Count(Lhv.SpecTable)  local Pos1, Pos2, Pos3, Pos4, AmH, AmV = Lhv.SpecRec.Pos1, Lhv.SpecRec.Pos2, Lhv.SpecRec.Pos3, Lhv.SpecRec.Pos4, (Lhv.SpecRec.AmountH or 2)-2, (Lhv.SpecRec.AmountV or 2)-2  Lhv.SpecTable[SAm+1] = Lhv.SpecRec.Pos1 Lhv.SpecTable[SAm+2] = Lhv.SpecRec.Pos2 Lhv.SpecTable[SAm+3] = Lhv.SpecRec.Pos3 Lhv.SpecTable[SAm+4] = Lhv.SpecRec.Pos4  if Lhv.SpecRec.Mid_Full then  for i=1, AmH do local TCnt = table.Count(Lhv.SpecTable) Lhv.SpecTable[TCnt+1] = LerpVector(i/(AmH+1), Pos1, Pos2)  if Lhv.SpecRec.Mid or Lhv.SpecRec.Mid_V then local SPos =  Lhv.SpecTable[TCnt+1] local EPos =  LerpVector(i/(AmH+1), Pos4, Pos3) local tSAm = table.Count(Lhv.SpecTable) for j=1, AmV do Lhv.SpecTable[tSAm+j] = LerpVector(j/(AmV+1), SPos, EPos) end end  end STSz=STSz+AmH  else  if Lhv.SpecRec.Mid then SAm = table.Count(Lhv.SpecTable) for i=1, AmH do Lhv.SpecTable[SAm+i] = LerpVector(i/(AmH+1), (Pos1+Pos4)/2, (Pos2+Pos3)/2) end end  if Lhv.SpecRec.Mid_V then SAm = table.Count(Lhv.SpecTable) for i=1, AmV do Lhv.SpecTable[SAm+i] = LerpVector(i/(AmV+1), (Pos1+Pos2)/2, (Pos3+Pos4)/2) end end  end  SAm = table.Count(Lhv.SpecTable) for i=1, AmH do Lhv.SpecTable[SAm+i] = LerpVector(i/(AmH+1), Pos1, Pos2) end STSz=STSz+AmH  SAm = table.Count(Lhv.SpecTable) for i=1, AmV do Lhv.SpecTable[SAm+i] = LerpVector(i/(AmV+1), Pos2, Pos3) end STSz=STSz+AmV  SAm = table.Count(Lhv.SpecTable) for i=1, AmH do Lhv.SpecTable[SAm+i] = LerpVector(i/(AmH+1), Pos3, Pos4) end STSz=STSz+AmH  SAm = table.Count(Lhv.SpecTable) for i=1, AmV do Lhv.SpecTable[SAm+i] = LerpVector(i/(AmV+1), Pos4, Pos1) end STSz=STSz+AmV  end   if Lhv.Spec3D and Lhv.Spec3D.Use and Lhv.Spec3D.Mat and Lhv.Spec3D.Mat != "" then  Lhv.Data_3D = {Pos1 = Lhv.Spec3D.Pos1, Pos2 = Lhv.Spec3D.Pos2, Pos3 = Lhv.Spec3D.Pos3, Pos4 = Lhv.Spec3D.Pos4, Mat = Material(Lhv.Spec3D.Mat), Color = Lhv.Spec3D.UseColor and Lhv.Spec3D.Color}  end   if Lhv.Spec3D and Lhv.Spec3D.Use and Lhv.Spec3D.Mat and Lhv.Spec3D.Mat != "" then  Lhv.Data_3D = {Pos1 = Lhv.Spec3D.Pos1, Pos2 = Lhv.Spec3D.Pos2, Pos3 = Lhv.Spec3D.Pos3, Pos4 = Lhv.Spec3D.Pos4, Mat = Material(Lhv.Spec3D.Mat), Color = Lhv.Spec3D.UseColor and Lhv.Spec3D.Color}  end   Lhv.Srn_CenterSz = (STSz*6+Size*3.5)/2   local CTbl = Lhv[col] if Lhv.RenderInner and Lhv.RenderInner_ClrUse and Lhv.RenderInner_Clr then Lhv.midColor = Lhv.RenderInner_Clr else if CTbl[1] > CTbl[2] and CTbl[1] > CTbl[3] then Lhv.midColor = {255,IsELS and 200 or 155,0} elseif CTbl[2] > CTbl[1] and CTbl[2] > CTbl[3] then Lhv.midColor = {255,255,255} elseif CTbl[3] > CTbl[1] and CTbl[3] > CTbl[2] then Lhv.midColor = {130,255,255} else Lhv.midColor = CTbl end end end  local function Send3DSpinPPData(ent, lht, tbl)  ent.Spin3D_Data = {}  if !ent.Spin3D_Data then ent.Spin3D_Data = {} end  if !ent.Spin3D_Data[lht] then ent.Spin3D_Data[lht] = true  net.Start("VC_Light_3DSpinPPData_Sync") net.WriteEntity(ent) net.WriteInt(lht, 8) net.WriteTable(tbl) net.SendToServer()  end end  local BeamTypes = {}  local function SetSubMaterial(ent, Lhk, int, nmat)  if !ent.VC_Light_SpecMat then ent.VC_Light_SpecMat = {} end  if !ent.VC_Light_SpecMat[int] then ent.VC_Light_SpecMat[int] = {}  if !ent.VC_Light_SpecMat[int][Lhk] then ent:SetSubMaterial(int-1, nmat or "models/wireframe") end  ent.VC_Light_SpecMat[int][Lhk] = true  end end  function VC.Handle_Light_Draw_Single(ent, Lhk, Lhv, col, colid, sideid, distnum, sizem, sizemd)  if Lhv and (!ent.VC_DamagedLights or !ent.VC_DamagedLights[Lhk]) then  local SPos = nil local Ang_Bone = nil    if Lhv.Pos then  SPos = Vector(Lhv.Pos.x, Lhv.Pos.y, Lhv.Pos.z)  if Lhv.Pos_Bone then local matrix = ent:GetBoneMatrix(Lhv.Pos_Bone) local Pos_Bone = ent:WorldToLocal(matrix:GetTranslation()) Ang_Bone = ent:WorldToLocalAngles(matrix:GetForward():Angle()) SPos:Rotate(Ang_Bone) SPos = SPos+Pos_Bone end  else  SPos = Vector(0,0,0)  end  local SPosM = nil local IsELS = col == "SirenColor" local IsDoor = col == "DoorColor"   if !sideid or (sideid == 1 and SPos.x < 0 and !Lhv.BlinkerRight or sideid == 2 and (SPos.x > 0 or Lhv.BlinkerRight)) then  local car = LocalPlayer():GetVehicle() if IsValid(car) then if IsValid(car:GetParent()) then car = car:GetParent() end else car = nil end local NotDark = IsDoor or ent.VC_Lht_CarBrght > 0.41   if Lhv.SpecMat and Lhv.SpecMat.Use and Lhv.SpecMat.Select then SetSubMaterial(ent, Lhk, Lhv.SpecMat.Select, Lhv.SpecMat.New) end   if (car and VC.CheckIsThirdPerson(ent) or Lhv.IsInterior or IsDoor or !VC.CheckViewerIsSelf() or car != ent) and Lhv.UseSprite and Lhv.Sprite then  if !ent.VC_Lights_PixVisTbl then ent.VC_Lights_PixVisTbl = {} end if !ent.VC_Lights_PixVisTbl[Lhk] then ent.VC_Lights_PixVisTbl[Lhk] = util.GetPixelVisibleHandle() end  if !SPosM then SPosM = ent:LocalToWorld(Lhv.SLSPos or SPos) end  local Vis = util.PixelVisible(SPosM, (Lhv.Sprite.GlowPrxSize or 2)*0.5, ent.VC_Lights_PixVisTbl[Lhk])*255 local VisOr = Vis  local Size = (Lhv.Sprite.Size or 6)*100*distnum if sizem then Size = Size*sizem end if NotDark then Size = Size*1.1 end   local SizeM = Size local SizeMHD = 1 local PrimeColor = Color(255,255,255,255) if Lhv.Inited then PrimeColor=Color(Lhv[col][1], Lhv[col][2], Lhv[col][3], 255) end local HLOf = 1 local LightBeamVis = 1  local InDetail = ent.VC_Lht_DstCheck < 2000 local SpinningSizeSync, SpinningAngSync = nil, nil  if Vis > 0 then  if !Lhv.Inited then Handle_Light_Init(Lhv, IsELS, col, SPos, Size) Lhv.Inited = true end    local IsFog = col == "FogColor" local IsBrake = col == "BrakeColor" local IsBack = SPos.y < 0   local BASize = Size  if IsFog and IsBack then Size = Size*2 end     local IntLS = Lhv.Srn_CenterSz if NotDark then IntLS = IntLS*1.1 end PrimeColor = Color(Lhv[col][1], Lhv[col][2], Lhv[col][3], Vis)  if Lhv.Data_3D and VC.Settings.Light_3D then   render.SetMaterial(Lhv.Data_3D.Mat) local dorender = true  local p1, p2, p3, p4 = Lhv.Data_3D.Pos1 or Vector(0,0,0), Lhv.Data_3D.Pos2 or Vector(0,0,0), Lhv.Data_3D.Pos3 or Vector(0,0,0), Lhv.Data_3D.Pos4 or Vector(0,0,0)   if Lhv.SpecSpin and Lhv.SpecSpin.Use then  local Spd = Lhv.SpecSpin.Speed or 0 local Ang = Angle(0,math.NormalizeAngle(CurTime()*Spd), 0)    if Lhv.SpecSpin.PParam then Send3DSpinPPData(ent, Lhk, Lhv.SpecSpin) end   if Lhv.SpecSpin.Offset then Ang.y = Ang.y+Lhv.SpecSpin.Offset end local Angy = VC.AngleDifference(Ang, ((SPosM-EyePos()):Angle()-Angle(0,ent:GetAngles().y,0))-Angle(0,90,0))-90  local BackSide = true local AngD = math.abs(Angy) if !Lhv.SpecSpin.Double and Angy < 0 then AngD = 0 BackSide = false end  local num = VC.EaseInOut(AngD/90) Size = Size/5+num*180*(Lhv.SpecSpin.Intensity or 1) IntLS = IntLS/2+num*IntLS Vis = num*255 SpinningSizeSync = num   if Lhv.SpecSpin.Rotated then Ang.y = Ang.y+90 end Ang.y = Ang.y+180 if Lhv.SpecSpin.Reversed then Ang.y = -Ang.y end  local ps1, ps2, ps3, ps4 = SPos-p1, SPos-p2, SPos-p3, SPos-p4  ps1:Rotate(Ang) ps2:Rotate(Ang) ps3:Rotate(Ang) ps4:Rotate(Ang) SpinningAngSync = Ang  p1 = ent:LocalToWorld(SPos+ps1) p2 = ent:LocalToWorld(SPos+ps2) p3 = ent:LocalToWorld(SPos+ps3) p4 = ent:LocalToWorld(SPos+ps4)   dorender = AngD >= 0 and BackSide  else  p1 = ent:LocalToWorld(p1) p2 = ent:LocalToWorld(p2) p3 = ent:LocalToWorld(p3) p4 = ent:LocalToWorld(p4)  end  if dorender then render.DrawQuad(p1, p2, p3, p4, Lhv.Data_3D.Color and Color(Lhv.Data_3D.Color[1], Lhv.Data_3D.Color[2], Lhv.Data_3D.Color[3], 255) or Color(Lhv.midColor[1],Lhv.midColor[2],Lhv.midColor[3], 255)) end  end   local OrVis = Vis if Lhv.ReducedVis then Vis = Vis*0.65 PrimeColor.a = Vis end   local ExrGlw = IsELS and VC.Settings.ELS_ExtraGlow local DrawM = !Lhv.DD_Main and VC.Settings.Light_Main local DrawHD = !Lhv.DD_HD and VC.Settings.Light_HD and InDetail local DrawGlow = !Lhv.DD_Glow and VC.Settings.Light_Glow and InDetail local DrawIn = VC.Settings.Light_Warm and InDetail and Lhv.RenderInner  if DrawM then DrawM = VC.Settings.Light_Main_M end if DrawHD then DrawHD = VC.Settings.Light_HD_M if Lhv.RenderHD_Size then DrawHD = DrawHD*Lhv.RenderHD_Size end end if DrawGlow then DrawGlow = VC.Settings.Light_Glow_M if Lhv.RenderGlow_Size then DrawGlow = DrawGlow*Lhv.RenderGlow_Size end end if DrawIn then DrawIn = VC.Settings.Light_Warm_M if Lhv.RenderInner_Size then DrawIn=DrawIn*Lhv.RenderInner_Size end end if ExrGlw then ExrGlw = VC.Settings.ELS_ExtraGlow_M end   if Lhv.SpecTable then   if DrawIn and Lhv.SpecTableBeam then  local SpecCnt = table.Count(Lhv.SpecTableBeam) local BeamClr = nil  BeamClr = Color(Lhv.midColor[1],Lhv.midColor[2],Lhv.midColor[3], OrVis) render.SetMaterial(VC.Material.Beam)  render.StartBeam(SpecCnt) local Sz = Size*DrawIn/10 DrawIn = false  for i=1, SpecCnt do local nsz = Sz if Lhv.SpecTableBeam[i].Size then nsz = Sz* Lhv.SpecTableBeam[i].Size end local BeamSeqClr = BeamClr if Lhv.SpecTableBeam[i].Clr then BeamSeqClr = Lhv.SpecTableBeam[i].Clr end render.AddBeam(ent:LocalToWorld(Lhv.SpecTableBeam[i].Pos), nsz, CurTime()+i, BeamSeqClr) end  render.EndBeam()  end   local SpecCnt = table.Count(Lhv.SpecTable)  if Lhv.RenderHD_Adv and DrawHD then local Sz = IntLS*DrawHD if sizem then Sz=Sz*sizem end render.SetMaterial(VC.HD_Texture) render.DrawSprite(SPosM, Sz*3, Sz, PrimeColor) end  if DrawIn or DrawM then  render.SetMaterial(VC.Material.Reg) local Sz = Size/2.5  local LastPos = nil VC.DrawMainHolt = false  for i=1, SpecCnt do    local TempPos = ent:LocalToWorld(Lhv.SpecTable[i])  if DrawIn then local Sz2=Sz*DrawIn render.DrawSprite(TempPos, Sz2, Sz2, Color(Lhv.midColor[1],Lhv.midColor[2],Lhv.midColor[3], OrVis)) end  if DrawM then  if Lhv.Beta_Inner3D then  if !VC.DrawMainHolt or !Lhv.DrawingSpecMLine then local temp = table.Copy(PrimeColor) temp.a = temp.a/5 local Sz2 = Size*DrawM*3 render.DrawSprite(TempPos, Sz2, Sz2, temp) VC.DrawMainHolt = true else VC.DrawMainHolt = false end  else  local Sz2 = Size*DrawM render.DrawSprite(TempPos, Sz2, Sz2, PrimeColor)  end  end      end  end  if DrawGlow then  local Sz = IntLS*DrawGlow*1.5 render.SetMaterial(VC.Material.Glow)  if ExrGlw then  Sz=Sz*7*ExrGlw render.DrawSprite(SPosM, Sz, Sz, Color(PrimeColor.r, PrimeColor.g, PrimeColor.b, PrimeColor.a*0.06))  else  Sz=Sz*1.2 render.DrawSprite(SPosM, Sz, Sz, Color(PrimeColor.r, PrimeColor.g, PrimeColor.b, PrimeColor.a*0.15))  end  end  else  local HLSOf = nil  if Lhv.UsePrjTex then  HLOf = IsFog and 0.6 or ent.VC_HighBeam and 0.4 or 0.5   local CAng = IsFog and 75 or ent.VC_HighBeam and 33 or 60 local Ang = math.abs(VC.AngleDifference(VC.AngleCombCalc(ent:GetForward():Angle(), Angle(30,0,0)), (SPosM-EyePos()):Angle())-90)  if Ang < CAng then LightBeamVis = VC.EaseInOut(Ang/CAng) HLOf = HLOf+(1-LightBeamVis)*((IsFog and 0.25 or ent.VC_HighBeam and 0.6 or 0.3)+(150-Size)/100) end  HLSOf = (Size/1.5+Vis/255)*HLOf  end  Size = Size*HLOf*0.85 if !HLSOf then HLSOf = Size end  render.SetMaterial(VC.Material.Reg)  if DrawIn then local Sz = Size/2.5*DrawIn render.DrawSprite(SPosM, Sz, Sz, Color(Lhv.midColor[1],Lhv.midColor[2],Lhv.midColor[3], Vis)) end  if DrawM then HLSOf=HLSOf*DrawM render.DrawSprite(SPosM, HLSOf, HLSOf, PrimeColor) end  if DrawHD then  Size=Size*DrawHD  if Size > 2 then  local NVis = Vis-100  if NVis > 0 then  render.SetMaterial(VC.HD_Texture)  render.DrawSprite(SPosM, Size/3, Size*3, Color(Lhv[col][1], Lhv[col][2], Lhv[col][3], NVis))  render.DrawSprite(SPosM, Size*3, Size, Color(PrimeColor.r, PrimeColor.g, PrimeColor.b, NVis))  end  end  end  if DrawGlow then  local Sz = IntLS*3*HLOf*DrawGlow render.SetMaterial(VC.Material.Glow) if Lhv.ReducedVis then PrimeColor.a = PrimeColor.a*1.535 end  if ExrGlw then  Sz=Sz*2*ExrGlw render.DrawSprite(SPosM, Sz, Sz, Color(PrimeColor.r, PrimeColor.g, PrimeColor.b, PrimeColor.a*0.05))  else  Sz=Sz*1.1 render.DrawSprite(SPosM, Sz, Sz, Color(PrimeColor.r, PrimeColor.g, PrimeColor.b, PrimeColor.a*0.11))  end  end  end  end   if InDetail then  if Lhv.UsePrjTex then  render.SetMaterial(VC.Material.HBeam)  if col == "HeadColor" then  if ent.VC_HighBeam then  local mult = (1-LightBeamVis)*1.8 if mult > 1 then mult = 1 end   local pos_end = SPosM- ent:GetRight()* 1000- ent:GetUp()*15  local pos_end2 = SPosM- ent:GetRight()* 700- ent:GetUp()*80  if Ang_Bone then  pos_end = ent:WorldToLocal(pos_end) pos_end:Rotate(Ang_Bone) pos_end = ent:LocalToWorld(pos_end)  pos_end2 = ent:WorldToLocal(pos_end2) pos_end2:Rotate(Ang_Bone) pos_end2 = ent:LocalToWorld(pos_end2)  end  local clr = PrimeColor clr.a = 2+8*mult render.DrawBeam(SPosM+ ent:GetRight()* 80, pos_end, 170, 1, 0, clr)  clr.a = 1+5*mult render.DrawBeam(SPosM+ ent:GetRight()* 20, pos_end2, 400, 1, 0, clr)            else  local pos_end = SPosM- ent:GetRight()* 700- ent:GetUp()*100  local pos_end2 = SPosM- ent:GetRight()* 500- ent:GetUp()*250  local pos_end3 = SPosM- ent:GetRight()* 300- ent:GetUp()*120  if Ang_Bone then  pos_end = ent:WorldToLocal(pos_end) pos_end:Rotate(Ang_Bone) pos_end = ent:LocalToWorld(pos_end)  pos_end2 = ent:WorldToLocal(pos_end2) pos_end2:Rotate(Ang_Bone) pos_end2 = ent:LocalToWorld(pos_end2)  pos_end3 = ent:WorldToLocal(pos_end3) pos_end3:Rotate(Ang_Bone) pos_end3 = ent:LocalToWorld(pos_end3)  end  local mult = (1-LightBeamVis)*1.3 if mult > 1 then mult = 1 end  local clr = PrimeColor clr.a = 2+8*mult render.DrawBeam(SPosM+ ent:GetRight()* 30, pos_end, 220, 1, 0, clr)  clr.a = 1+2*mult render.DrawBeam(SPosM+ ent:GetRight()* 50, pos_end2, 800, 1, 0, clr)  clr.a = 5 render.DrawBeam(SPosM+ ent:GetRight() * 20, pos_end3, 500, 1, 0, clr)  end  else  local mult = (1-LightBeamVis)*1.3 if mult > 1 then mult = 1 end  local pos_end = SPosM- ent:GetRight()* 300- ent:GetUp()*100  local pos_end2 = SPosM- ent:GetRight()* 500- ent:GetUp()*250  local pos_end3 = SPosM- ent:GetRight()* 300- ent:GetUp()*120  if Ang_Bone then  pos_end = ent:WorldToLocal(pos_end) pos_end:Rotate(Ang_Bone) pos_end = ent:LocalToWorld(pos_end)  pos_end2 = ent:WorldToLocal(pos_end2) pos_end2:Rotate(Ang_Bone) pos_end2 = ent:LocalToWorld(pos_end2)  pos_end3 = ent:WorldToLocal(pos_end3) pos_end3:Rotate(Ang_Bone) pos_end3 = ent:LocalToWorld(pos_end3)  end  local clr = PrimeColor clr.a = 2+8*mult render.DrawBeam(SPosM+ ent:GetRight()* 30, pos_end, 600, 1, 0, clr)  clr.a = 1+2*mult render.DrawBeam(SPosM+ ent:GetRight()* 50, pos_end2, 800, 1, 0, clr)  clr.a = 5 render.DrawBeam(SPosM+ ent:GetRight() * 20, pos_end3, 500, 1, 0, clr)  end  end   if SpinningSizeSync and Lhv.Data_3D and VC.Settings.Light_3D and Lhv.SpecSpin and Lhv.SpecSpin.Use and !Lhv.SpecSpin.dd_beam then  render.SetMaterial(VC.Material.HBeam)  local FP = (SPosM- ent:GetRight()* 200)-SPosM  FP:Rotate(SpinningAngSync+Angle(0,180-(Lhv.SpecSpin.Rotated and 90 or 0),0))   local clr = table.Copy(PrimeColor) clr.a = 2+15*SpinningSizeSync  render.DrawBeam(SPosM, SPosM+FP, 200, 1, 0, clr)  end  end  end   if Lhv.UseDynamic and Lhv.Dynamic and VC.Settings.DynamicLights and ent.VC_LhtSzOffset_D > 0 and (!IsELS or VC.Settings.ELS_Dyn_Enabled) then  if !SPosM then SPosM = ent:LocalToWorld(Lhv.SLSPos or SPos) end  if !NotDark then  local DLight = DynamicLight(ent:EntIndex()..Lhk..colid)  DLight.Pos = SPosM  DLight.r = Lhv[col][1] DLight.g = Lhv[col][2] DLight.b = Lhv[col][3]  DLight.Brightness = (Lhv.Dynamic.Brightness or 1)/2  local Sz = 180*(Lhv.Dynamic.Size or 1)*distnum if sizemd then Sz=Sz*sizemd end DLight.Size = Sz*ent.VC_LhtSzOffset_D*(IsELS and VC.Settings.ELS_Dyn_Mult or 1)  DLight.Decay = 500 DLight.DieTime = CurTime()+0.5  if IsDoor then DLight.Decay = 100 DLight.DieTime = CurTime()+0.1 end  end  end  end  ent.VC_LastRenderedL[Lhk] = Lhv[col]  end end  local function Handle_Light_Draw_Multi(ent, ltable, col, colid, sideid, distnum, sizem) for Lhk, Lhv in pairs(ltable) do if Lhv and VC.BGroups_Check(ent, "Lht"..Lhk, Lhv.BGroups) then VC.Handle_Light_Draw_Single(ent, Lhk, Lhv, col, colid, sideid, distnum) end end end  local function DataReqCheck(ent)  if !ent.VC_Model_IsNull then  if !ent.VC_Model then  net.Start("VC_RequestVehData_Model") net.WriteEntity(ent) net.SendToServer()  elseif !VC.Global_Data[ent.VC_Model] then  net.Start("VC_RequestVehData") net.WriteEntity(ent) net.SendToServer()  elseif !ent.VC_Initialized then VC.Initialize(ent) ent.VC_Initialized = true  end  end end  local function HandleSpecMat(ent)  if ent.VC_Light_SpecMat then  for k,v in pairs(ent.VC_Light_SpecMat) do  local can = false for k2, v2 in pairs(v) do if can then if ent.VC_LastRenderedL[k2] then can = false break end elseif !ent.VC_LastRenderedL[k2] then can = k2 end end  if can then ent:SetSubMaterial(k-1, nil) ent.VC_Light_SpecMat[k][can] = nil end  if table.Count(ent.VC_Light_SpecMat[k]) == 0 then ent.VC_Light_SpecMat[k] = nil end  end  if table.Count(ent.VC_Light_SpecMat) == 0 then ent.VC_Light_SpecMat = nil end  end end  concommand.Add("VC_BETA_PDTR", function(ply) if !VC_BETA_PDTR then VC_BETA_PDTR = true else VC_BETA_PDTR = nil end end)  hook.Add("PostDrawTranslucentRenderables", "VC_PostDrawTranslucentRenderables", function()  local CanUpdate = !VC.SyncTimeCheck or CurTime() >= VC.SyncTimeCheck  for _, ent in pairs(VC.GetVehicleList()) do  if IsValid(ent) then if VC_BETA_PDTR then if type(VC_BETA_PDTR) != "table" then VC_BETA_PDTR = {} VCMsg("Switching to BETA light rendering.") end   local PRenL = ent.VC_LastRenderedL ent.VC_LastRenderedL = {} local MEnt = ent.VC_ExtraSeat and ent:GetParent() or ent  if CanUpdate then DataReqCheck(ent) end  if ent.VC_Model and VC.Global_Data[ent.VC_Model] then   if !ent.VC_Lht_ChkT or CurTime() >= ent.VC_Lht_ChkT then  local LInt = render.GetLightColor(ent:LocalToWorld(ent:OBBCenter())) ent.VC_Lht_CarBrght = (LInt.x+LInt.y+LInt.z)/3  ent.VC_Lht_DstCheck = LocalPlayer():GetPos():Distance(ent:GetPos()) ent.VC_Lht_DstCheck_B = ent.VC_Lht_DstCheck < (VC.Settings.LightDistance or 8000) if !ent.VC_Lht_DstCheckMult then ent.VC_Lht_DstCheckMult = 1 end  if VC.Settings.DynamicLights and ((VC.Settings.DynamicLights_OffDist or 2500)-1000) < (ent.VC_Lht_DstCheck) then  local Am = VC.Settings.DynamicLights_OffDist or 2500  if Am < ent.VC_Lht_DstCheck then ent.VC_LhtSzOffset_D = 0 else ent.VC_LhtSzOffset_D = (Am-ent.VC_Lht_DstCheck)/1000 end  else  ent.VC_LhtSzOffset_D = 1  end  ent.VC_Lht_ChkT = CurTime()+0.5  end  if ent.VC_Lht_DstCheck_B then  if ent.VC_Lht_DstCheckMult < 1 then ent.VC_Lht_DstCheckMult = ent.VC_Lht_DstCheckMult+0.01*VC.FTm() if ent.VC_Lht_DstCheckMult > 1 then ent.VC_Lht_DstCheckMult = 1 end end  elseif ent.VC_Lht_DstCheckMult > 0 then ent.VC_Lht_DstCheckMult = ent.VC_Lht_DstCheckMult-0.01*VC.FTm() if ent.VC_Lht_DstCheckMult < 0 then ent.VC_Lht_DstCheckMult = 0 end  end   if ent.VC_Lht_DstCheckMult > 0 then  local LhtTbl = VC.Global_Data[ent.VC_Model].LightTable    if VC.HandleELSLights and LhtTbl then VC.HandleELSLights(ent, LhtTbl) end     if ent:GetNWBool("VC_Lights_Running_Created") and LhtTbl and LhtTbl.Running then VC.Handle_Light_Draw_Multi_B(ent, LhtTbl.Running, "RunningColor", 3, nil, ent.VC_Lht_DstCheckMult) end                        end end    else  local PRenL = ent.VC_LastRenderedL ent.VC_LastRenderedL = {} local MEnt = ent.VC_ExtraSeat and ent:GetParent() or ent  if !VCMod2 or ent:GetNWBool("VC_HasElectricity") or !ent:IsVehicle() then  if CanUpdate then DataReqCheck(ent) end  if VC.Handle_PDTR_Alarm then VC.Handle_PDTR_Alarm(ent) end   if ent.VC_Model and VC.Global_Data[ent.VC_Model] then   if !ent.VC_Lht_ChkT or CurTime() >= ent.VC_Lht_ChkT then  local LInt = render.GetLightColor(ent:LocalToWorld(ent:OBBCenter())) ent.VC_Lht_CarBrght = (LInt.x+LInt.y+LInt.z)/3  ent.VC_Lht_DstCheck = LocalPlayer():GetPos():Distance(ent:GetPos()) ent.VC_Lht_DstCheck_B = ent.VC_Lht_DstCheck < (VC.Settings.LightDistance or 8000) if !ent.VC_Lht_DstCheckMult then ent.VC_Lht_DstCheckMult = 1 end  if VC.Settings.DynamicLights and ((VC.Settings.DynamicLights_OffDist or 2500)-1000) < (ent.VC_Lht_DstCheck) then  local Am = VC.Settings.DynamicLights_OffDist or 2500  if Am < ent.VC_Lht_DstCheck then ent.VC_LhtSzOffset_D = 0 else ent.VC_LhtSzOffset_D = (Am-ent.VC_Lht_DstCheck)/1000 end  else  ent.VC_LhtSzOffset_D = 1  end  ent.VC_Lht_ChkT = CurTime()+0.5  end   if ent.VC_Lht_DstCheck_B then  if ent.VC_Lht_DstCheckMult < 1 then ent.VC_Lht_DstCheckMult = ent.VC_Lht_DstCheckMult+0.01*VC.FTm() if ent.VC_Lht_DstCheckMult > 1 then ent.VC_Lht_DstCheckMult = 1 end end  elseif ent.VC_Lht_DstCheckMult > 0 then ent.VC_Lht_DstCheckMult = ent.VC_Lht_DstCheckMult-0.01*VC.FTm() if ent.VC_Lht_DstCheckMult < 0 then ent.VC_Lht_DstCheckMult = 0 end  end   if ent.VC_Lht_DstCheckMult > 0 then  local LhtTbl = VC.Global_Data[ent.VC_Model].LightTable    if VC.HandleELSLights and LhtTbl then VC.HandleELSLights(ent, LhtTbl) end   if ent:GetNWBool("VC_Lights_Brk_Created") and LhtTbl and LhtTbl.Brake then Handle_Light_Draw_Multi(ent, LhtTbl.Brake, "BrakeColor", 2, nil, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Running_Created") and LhtTbl and LhtTbl.Running then Handle_Light_Draw_Multi(ent, LhtTbl.Running, "RunningColor", 3, nil, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Fog_Created") and LhtTbl and LhtTbl.Fog then Handle_Light_Draw_Multi(ent, LhtTbl.Fog, "FogColor", 3, nil, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Rev_Created") and LhtTbl and LhtTbl.Reverse then Handle_Light_Draw_Multi(ent, LhtTbl.Reverse, "ReverseColor", 4, nil, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Head_Created") and LhtTbl and LhtTbl.Head then ent.VC_HighBeam = ent:GetNWBool("VC_HighBeam") Handle_Light_Draw_Multi(ent, LhtTbl.Head, "HeadColor", 5, nil, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Alarm_Created") and LhtTbl and LhtTbl.Blinker then Handle_Light_Draw_Multi(ent, LhtTbl.Blinker, "BlinkersColor", 6, nil, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Hazards_Created") and LhtTbl and LhtTbl.Blinker then Handle_Light_Draw_Multi(ent, LhtTbl.Blinker, "BlinkersColor", 6, nil, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Blinker_Created_Left") and LhtTbl and LhtTbl.Blinker then Handle_Light_Draw_Multi(ent, LhtTbl.Blinker, "BlinkersColor", 6, 1, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Blinker_Created_Right") and LhtTbl and LhtTbl.Blinker then Handle_Light_Draw_Multi(ent, LhtTbl.Blinker, "BlinkersColor", 6, 2, ent.VC_Lht_DstCheckMult) end  if ent:GetNWBool("VC_Lights_Door_Created") then  if !ent.VC_Initialized then VC.Initialize(ent) ent.VC_Initialized = true end  if ent.VC_DoorLightPos then VC.Handle_Light_Draw_Single(ent, -45, {Pos = ent.VC_DoorLightPos, UseSprite = true, Sprite = {Size = 0.1}, UseDynamic = true, Dynamic = {Brightness = 5, Size = 0.5}, DoorColor = {255,255,255}}, "DoorColor", 1, nil, ent.VC_Lht_DstCheckMult) end  end  end  end  end  HandleSpecMat(ent) end  end  end  if CanUpdate then VC.SyncTimeCheck = CurTime()+1 end end) local rs7 = "vc.check_msg_work_ALS_k4" 