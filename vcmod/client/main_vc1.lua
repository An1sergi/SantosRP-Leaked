
-----------------------------------------------------
local Controls = {  {cmd = "vc_hazards_onoff", menu = "controls", keyhold = true, info = "HazardLights", default = {key = "MOUSE_MIDDLE", hold = "0", mouse = "1"}},  {cmd = "vc_blinker_left", menu = "controls", keyhold = true, info = "BlinkerLeft", default = {key = "MOUSE_LEFT", hold = "0", mouse = "1"}},  {cmd = "vc_blinker_right", menu = "controls", keyhold = true, info = "BlinkerRight", default = {key = "MOUSE_RIGHT", hold = "0", mouse = "1"}},  {cmd = "vc_runninglights_onoff", menu = "controls", info = "RunningLights", default = {key = "KEY_F", hold = "1"}},  {cmd = "vc_foglights_onoff", menu = "controls", keyhold = true, info = "FogLights", default = {key = "KEY_F", hold = "1"}},  {cmd = "vc_headlights_onoff", menu = "controls", info = "HeadLights", default = {key = "KEY_F", hold = "0"}},  {cmd = "vc_headlights_modes", menu = "controls", keyhold = true, info = "LowHighBeamToggle", default = {key = "KEY_F", hold = "0"}},  {cmd = "vc_cruise_onoff", menu = "controls", info = "Cruise", default = {key = "KEY_B", hold = "0"}},  {cmd = "VC_Trailer_Detach", menu = "controls", info = "DetachTrailer", default = {key = "KEY_B", hold = "1"}},  {cmd = "vc_viewlookbehind", menu = "controls", NoCheckBox = true, carg1 = "1", carg2 = "2", info = "LookBehind", default = {key = "MOUSE_MIDDLE", hold = "1", mouse = "1"}, desk = "Look behind the vehicle."},  {cmd = "vc_inside_doors_onoff", menu = "controls", info = "LockUnlock", keyhold = true, default = {key = "KEY_N", hold = "0"}, desk = "Lock the vehicle from within."}, }  for k,v in pairs(Controls) do  local added = false for k2,v2 in pairs(VC.Controls_Main) do if v.cmd == v2.cmd then added = true break end end  if !added then table.insert(VC.Controls_Main, v) end end   local settings = { HUD_Height = 35, HUD_Name = true, HUD_Name_Height = 0.75, HUD_PickUp = true, HUD_Health = true, HUD_Icons = true, HUD_Cruise = true, HUD_Repair = true,  HUD_MPh = true,  ThirdPerson_Dynamic = true, ThirdPerson_Auto = true, ThirdPerson_Vec_Stf = 100, ThirdPerson_Ang_Stf = 15, ThirdPerson_Auto_Pitch = 5, ThirdPerson_Ang_Pitch = true, ThirdPerson_Auto_Back = true, ThirdPerson_Switch = false, ThirdPerson_Cam_Trl = true, ThirdPerson_Speed = true, ThirdPerson_Hight_Auto = true, ThirdPerson_Type = 1, } table.Merge(VC.Settings_Defaults, settings)    concommand.Add("vc_viewlookbehind", function(ply, cmd, arg) local HA = tonumber(arg[1]) if HA == 1 and !VC.View_LookingBehind then VC.View_LookingBehind = true elseif HA == 2 and VC.View_LookingBehind then VC.View_LookingBehind = false end end)  function VC.Handle_Input_VC1(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC)  if VSC and !vgui.CursorVisible() then  if (!ply.VC_UpKeysPressTime or CurTime() >= ply.VC_UpKeysPressTime) then  if input.IsKeyDown(KEY_LALT) and !ent.VC_ExtraSeat then  for i=1, 10 do local Ib = (i == 10 and 0 or i) if input.IsKeyDown(_G["KEY_"..Ib]) then RunConsoleCommand("VC_ClearSeat", Ib) ply.VC_UpKeysPressTime = CurTime()+0.2 end end  else  for i=1, 10 do local Ib = (i == 10 and 0 or i) if input.IsKeyDown(_G["KEY_"..Ib]) then if Ib > 0 then RunConsoleCommand("VC_Switch_Seats_"..Ib) else RunConsoleCommand("VC_Switch_Seats") end ply.VC_UpKeysPressTime = CurTime()+0.2 end end  end  end  end end  if !vcmod2 then concommand.Add("vc_getparticles", function(ply, cmd, arg) VCMsg('Particle effects are not bundled with VCMod for legal reasons.\nYou can still get them here: "http://www.filedropper.com/vcmodparticles".') end) local function CheckForEffects() if !file.Exists("models/vehicle.mdl", "GAME") and !file.Exists("particles/vehicle.pcf", "GAME") then VCMsg('WARNING, missing particle effects, enter "vc_getparticles" in console to get them.') end end timer.Create("vcmod_pcheck", 30, 4, function() CheckForEffects() end) timer.Simple(10, function() CheckForEffects() end) game.AddParticles("particles/vehicle.pcf") game.AddParticles("particles/weapon_fx.pcf") end   VC.DrawFT["Repair"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  local TVeh, TPos = nil, nil local Wep = ply:GetActiveWeapon() if !IsValid(Wep) then Wep = nil end local On = !IsValid(ply:GetVehicle()) and Wep and (Wep:GetClass() == "vc_wrench" or Wep:GetClass() == "vc_repair")  if On then TVeh, TPos = VC.GetVehicle(ply) if !TVeh or !TVeh:IsVehicle() then On = false end if TPos:Distance(ply:GetPos()) > 70 then On = nil end end  local Lrp = "Repair" VC.DrawFT["Lerp"](On, Lrp, 0.05, 0.05)   if VC.Anim_Lerp[Lrp] then  local Int = 0  if On and IsValid(TVeh) then  Int = TVeh:GetNWInt("VC_Health")  if Int < 0 then Int = 0 end  if TVeh:GetNWInt("VC_MaxHealth") > 0 then Int = Int/TVeh:GetNWInt("VC_MaxHealth") end  ply.VC_HUD_Rep_LastInt = Lerp(0.1, ply.VC_HUD_Rep_LastInt or 0, Int)  end   Int = ply.VC_HUD_Rep_LastInt or 0   draw.RoundedBox(4, ScrW()/2- 300/2+CARot[1], ScrH()/1.1-15+CARot[2], 300, 45, Color(0, 0, 0, 150*VC.Anim_Lerp[Lrp]))  if !VC.Fonts["VC_Cruise"] then VC.Fonts["VC_Cruise"] = true surface.CreateFont("VC_Cruise", {font = "MenuLarge", size = 26, weight = 1000, blursize = 0, scanlines = 0, antialias = true, underline = false, italic = false, strikeout = false, symbol = false, rotary = false, shadow = false, additive = false,outline = false}) end  if !VC.Fonts["VC_RepairSmall"] then VC.Fonts["VC_RepairSmall"] = true surface.CreateFont("VC_RepairSmall", {font = "MenuLarge", size = 16, weight = 1000, blursize = 0, scanlines = 0, antialias = true, underline = false, italic = false, strikeout = false, symbol = false, rotary = false, shadow = false, additive = false,outline = false}) end  draw.SimpleText(VC.Lng("RepairingVehicle"), "VC_Cruise", ScrW()/2+CARot[1], ScrH()/1.1-3+CARot[2], Color(255, 255, 255, 255*VC.Anim_Lerp[Lrp]), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)   draw.RoundedBox(0, ScrW()/2- 295/2+CARot[1], ScrH()/1.1+13+CARot[2], 295, 15, Color(0, 0, 0, 150*VC.Anim_Lerp[Lrp]))  draw.RoundedBox(0, ScrW()/2- 295/2+CARot[1], ScrH()/1.1+13+CARot[2], 295*Int, 15, Int < 0.125 and Color(255,0,0,150*VC.Anim_Lerp[Lrp]) or Int < 0.4 and Color(255,155,0,150*VC.Anim_Lerp[Lrp]) or Color(0, 100+155*Int, 100+155*(1-Int), 150*VC.Anim_Lerp[Lrp]))  draw.SimpleText(VC.Lng("Health")..": "..math.Round(Int*100).."%", "VC_RepairSmall", ScrW()/2+CARot[1], ScrH()/1.1+19+CARot[2], Color(255, 255, 255, 255*VC.Anim_Lerp[Lrp]), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)  end end  VC.DrawFT["Name"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  if !ply.VC_HUD_Name_Tm and IsValid(ent) then ply.VC_HUD_PNam = Veh:GetNWString("VC_Name") ply.VC_HUD_Name_Tm = CurTime()+3 elseif ply.VC_HUD_Name_Tm and !IsValid(ent) then ply.VC_HUD_Name_Tm = nil end  local Lrp = "Name" VC.DrawFT["Lerp"](ply.VC_HUD_Name_Tm and CurTime() < ply.VC_HUD_Name_Tm, Lrp, 0.01, 0.005)   if VC.Anim_Lerp[Lrp] and ply.VC_HUD_PNam != "" then  local Num = VC.EaseInOut(VC.Anim_Lerp[Lrp]) CARot = CARot or CalcRot()  surface.SetFont("VC_Name") local Wth = surface.GetTextSize(ply.VC_HUD_PNam)+80 if !VC.Fonts["VC_Name"] then VC.Fonts["VC_Name"] = true surface.CreateFont("VC_Name", {font = "tahoma", size = 30, weight = 1000, blursize = 0, scanlines = 0, antialias = true, underline = false, italic = false, strikeout = false, symbol = false, rotary = false, shadow = false, additive = false,outline = false}) end   local height = VC.Settings.HUD_Name_Height or 0.75  local SizeXe = math.Round((Wth+CARot[1])*math.Clamp(Num*10,0,1)) local PosY = math.Round(ScrH()*height+CARot[2])  local tclr = VC.Color.Main draw.RoundedBox(0, -30, PosY, SizeXe, 45, tclr) surface.SetDrawColor(tclr.r,tclr.g,tclr.b,tclr.a) surface.SetMaterial(VC.Material.Fade) surface.DrawTexturedRect(math.Round(SizeXe-30), PosY, 45, 45)   draw.RoundedBox(0, 0, math.Round(ScrH()*height+CARot[2]+35), (Wth+CARot[1]-15)*math.Clamp(Num*3,0,1), 2, Color(100, 255, 55, 255))  draw.SimpleText(ply.VC_HUD_PNam, "VC_Name", math.Round(Wth+CARot[1]-35+(35*Num-35)), math.Round(ScrH()*height+CARot[2]+20), Color(255, 255, 255, 255*math.Clamp((Num-0.25)*1.25, 0, 1)), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)  end end  VC.DrawFT["Cruise"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  local Lrp = "Cruise" VC.DrawFT["Lerp"](DrvV and ent == Veh and ent:GetNWInt("VC_Cruise_Spd") > 0, Lrp, 0.05, 0.05)   if VC.Anim_Lerp[Lrp] then  CARot = CARot or CalcRot()  local CCVel = ent and ent:GetNWInt("VC_Cruise_Spd") or 0  if DrvV and (ply:KeyDown(IN_FORWARD) or ply:KeyDown(IN_BACK)) then if !ply.VC_Cruise_KDV or ply.VC_Cruise_KDV < 1 then ply.VC_Cruise_KDV = math.Round(((ply.VC_Cruise_KDV or 0)+ 0.1)*100)/100 end CCVel = -ent:GetVelocity():Dot(ent:GetRight()) elseif ply.VC_Cruise_KDV then if ply.VC_Cruise_KDV > 0 then ply.VC_Cruise_KDV = math.Round((ply.VC_Cruise_KDV- 0.1)*100)/100 end end  local SCVr = math.Clamp((ply.VC_Cruise_HUD_L or 0)/5-5, 0, 20)*(1-(ply.VC_Cruise_KDV or 0))  local Miles = VC.Settings.HUD_MPh  CCVel = (CCVel > 10 and CCVel or 10)* (Miles and 0.0568181818 or 0.09144) ply.VC_Cruise_HUD_L = Lerp(0.05*VC.FTm(), ply.VC_Cruise_HUD_L or 0, CCVel)   draw.RoundedBox(0, ScrW()/2- (300/2+15*(ply.VC_Cruise_KDV or 0))*VC.Anim_Lerp[Lrp]+CARot[1], ScrH()/1.1+ (20+ (15-VC.Anim_Lerp[Lrp]*15)+CARot[2]), (300+25*(ply.VC_Cruise_KDV or 0))*VC.Anim_Lerp[Lrp], 2, Color(100, 255, 55, 255*VC.Anim_Lerp[Lrp]))  if !VC.Fonts["VC_Cruise"] then VC.Fonts["VC_Cruise"] = true surface.CreateFont("VC_Cruise", {font = "MenuLarge", size = 26, weight = 1000, blursize = 0, scanlines = 0, antialias = true, underline = false, italic = false, strikeout = false, symbol = false, rotary = false, shadow = false, additive = false,outline = false}) end  draw.SimpleText(VC.Lng("CruisingAt").." "..tostring(math.Round(ply.VC_Cruise_HUD_L)).." "..(Miles and "mi/h" or "km/h")..".", "VC_Cruise", ScrW()/2+CARot[1], ScrH()/1.1+(10-VC.Anim_Lerp[Lrp]*10)+CARot[2], Color(255, 255-200*(ply.VC_Cruise_KDV or 0), 255-200*(ply.VC_Cruise_KDV or 0), 180*VC.Anim_Lerp[Lrp]+math.sin(CurTime()*5+SCVr/3)*35), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)  elseif ply.VC_Cruise_HUD_L then  ply.VC_Cruise_HUD_L = nil ply.VC_Cruise_KDV = nil  end end  VC.DrawFT["PickUp"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  for k,v in pairs(ents.FindByClass("vc_pickup*")) do  local Vis = util.PixelVisible(v:GetPos()+Vector(0,0,25), 1, v.VC_PVsb)  local Dist = nil if Vis > 0 then Dist = EyePos():Distance(v:GetPos()) end  local Lrp = "Pickup_"..k VC.DrawFT["Lerp"](Vis > 0 and Dist < (VC.Settings.PickupDistance or 2500), Lrp, 0.05, 0.05)  if VC.Anim_Lerp[Lrp] then  local VisM = VC.Anim_Lerp[Lrp]*255  surface.SetDrawColor(v.VC_Color.r, v.VC_Color.g, v.VC_Color.b, VisM)  local Pos = v:GetPos():ToScreen() local PSx,PSy = Pos.x, Pos.y local PEx,PEy = Pos.x+20, Pos.y-15  local chunks = string.Explode(" ", v.VC_Text) local text = string.gsub(VC.Lng("Pickup_"..chunks[2]), ":val:", chunks[3].."%")  draw.SimpleText(text, "VC_Name", PEx+5, PEy-10, Color(255, 255, 255, VisM), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)  local tsize = surface.GetTextSize(text)  surface.DrawLine(PSx, PSy, PEx+1, PEy) surface.DrawLine(PSx, PSy+1, PEx, PEy+1) surface.DrawLine(PSx, PSy+2, PEx, PEy+2)  draw.RoundedBox(0, PEx, PEy, tsize+5, 2, Color(v.VC_Color.r, v.VC_Color.g, v.VC_Color.b, VisM))  surface.SetMaterial(VC.Material.Circle_32) surface.DrawTexturedRect(PSx-4, PSy-2, 8, 8)  end  end end  local View_Auto_InOutInt = 0 function VC.View_Handle_Auto(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View)  local LookBehind = VC.View_LookingBehind and !vgui.CursorVisible() if LookBehind then VC.View_Auto_LastLookBehind = CurTime()+0.5 end local LookBehindRev = nil if VC.View_Auto_LastLookBehind and CurTime() < VC.View_Auto_LastLookBehind then LookBehindRev = true else VC.View_Auto_LastLookBehind = nil end   if LookBehind or LookBehindRev or !CursorVis and (VC.Settings.ThirdPerson_Auto and IsThirdPerson and VC.Settings.ThirdPerson_Ang_Stf > 0 or VC.Settings.FirstPerson_Auto and !IsThirdPerson and VC.Settings.FirstPerson_Ang_Stf > 0 and !ply.VC_InGunMode) and !Veh.VC_IsAirboat and CurTime() >= (ply.VC_View_LastMouseMovedTime or (CurTime()+ 1))+ (Veh:GetVelocity():Length() >= 50 and 1.5 or ply.VC_LEAACR) then  local LBP = nil if !IsThirdPerson then LBP = Veh:WorldToLocal(ply:EyePos()).x > 5 and -105 or -75 else LBP = -90 end  local FAng = (IsThirdPerson and VC.Settings.ThirdPerson_Auto_Back or !IsThirdPerson and VC.Settings.FirstPerson_Auto_Back) and Veh == ent and (LookBehind or LookBehindRev or VCMod2 and (Veh:GetNWInt("VC_Throttle") == 0 or Veh:GetNWInt("VC_Gear") < 0) or input.IsKeyDown(KEY_S)) and (Veh:GetVelocity():Dot(Veh:GetRight()) > 150 or LookBehind) and LBP or 90  if !VC.AngleInBounds(0.1, ply.VC_View_Angle_Real or ply:EyeAngles(), Angle(IsThirdPerson and VC.Settings.ThirdPerson_Auto_Pitch or 0,FAng,0)) then  local AVel = math.Clamp(Veh:GetVelocity():Length()/(FAng > 0 and (IsThirdPerson and 25000 or 22000) or (IsThirdPerson and 13000 or 10000)), 0, 0.0775)  if ply.VC_APLBP and ply.VC_APLBP != FAng then View_Auto_InOutInt = 0 end ply.VC_APLBP = FAng if View_Auto_InOutInt < 1 then View_Auto_InOutInt = View_Auto_InOutInt+ 0.005+ AVel*VC.FTm() end if View_Auto_InOutInt > 1 then View_Auto_InOutInt = 1 end  local CAng = LerpAngle(((LookBehind or LookBehindRev) and 0.1 or (0.003+ AVel)*View_Auto_InOutInt)*VC.FTm(), ply.VC_View_Angle_Real, (Veh:GetAngles()- ent:GetAngles())+ Angle(IsThirdPerson and VC.Settings.ThirdPerson_Auto_Pitch or 0, FAng, 0))  local PAng = ply:EyeAngles()- (ply.VC_View_Angle_Real- CAng)  ply:SetEyeAngles(Angle(PAng.p, PAng.y, ply:EyeAngles().r))  ply.VC_View_Angle_Real = Angle(CAng.p, CAng.y, ply:EyeAngles().r)  ply.VC_View_Angle_Simulated = ply:EyeAngles()  ply.VC_View_LastMouseMovedTime = 1  else  View_Auto_InOutInt = 0  end  else  View_Auto_InOutInt = 0  end  return View end  function VC.View_Handle_Mouse_Movement(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View)  local MMvd = false  if !ply.VC_View_Angle_Simulated or !VC.AngleInBounds(0.0001, ply.VC_View_Angle_Simulated, ply:EyeAngles()) then ply.VC_View_Angle_Real = (ply.VC_View_Angle_Real or ply:EyeAngles())+ (ply:EyeAngles()- (ply.VC_View_Angle_Simulated or ply:EyeAngles())) ply.VC_View_Angle_Simulated = ply.VC_View_Angle_Real MMvd = true end  if MMvd or !CursorVis and (input.IsMouseDown(MOUSE_LEFT) or input.IsMouseDown(MOUSE_RIGHT) or VC.View_LookingBehind) then ply.VC_View_LastMouseMovedTime = CurTime() ply.VC_LEAACR = math.random(4.5, 6) end  return MMvd end  function View_Handle_TP_Hight_Auto(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View, Fltr, APos, APVD)  local Int = 1  if VC.Settings.ThirdPerson_Hight_Auto then  local CVel = Veh:GetVelocity():Length() CVel = (CVel- 150)*0.04 if CVel < 0 then CVel = 0 end if CVel > 20 then CVel = 20 end  ply.VC_ViewTP_UpL = Lerp(0.02*VC.FTm(), ply.VC_ViewTP_UpL or CVel, CVel) Int = ply.VC_ViewTP_UpL  if !IsNotPod and VSC then Int = Int+100 end  end  return Int end  function View_Handle_TP_Hight_Auto_Speed(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View, Fltr, APos, APVD, HMlt)  if VC.Settings.ThirdPerson_Speed then  APos = APos+ ang:Up()*(15+HMlt)  APos = APos- ang:Forward()*(15+HMlt)  end  return APos end  function View_Handle_TP_Trailer(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View, Fltr, APos, APVD)  if VC.Settings.ThirdPerson_Cam_Trl and IsValid(Veh:GetNWEntity("VC_HookedVh")) then  if !Veh.VC_TrlVwMult or Veh.VC_TrlVwMult < 1 then Veh.VC_TrlVwMult = math.Round(((Veh.VC_TrlVwMult or 0)+ 0.01*VC.FTm())*100)/100 end  elseif Veh.VC_TrlVwMult then  if Veh.VC_TrlVwMult > 0 then Veh.VC_TrlVwMult = math.Round((Veh.VC_TrlVwMult- 0.01*VC.FTm())*100)/100 else Veh.VC_TrlVwMult = nil end  end   if Veh.VC_TrlVwMult then  if IsValid(Veh:GetNWEntity("VC_HookedVh")) then ply.VC_TrlAPos = Veh:GetNWEntity("VC_HookedVh"):LocalToWorld(Veh:GetNWEntity("VC_HookedVh"):OBBCenter())+Veh:GetUp()*60 ply.VC_TrlAPVD = math.Max(100, Veh:GetNWEntity("VC_HookedVh"):BoundingRadius()) end  local VwMul = (math.sin(math.pi*(Veh.VC_TrlVwMult-0.5))+1)/2 APos = LerpVector(VwMul, APos, (APos+ ply.VC_TrlAPos)/2) APVD = APVD+ply.VC_TrlAPVD*VwMul Fltr = {Veh, Veh:GetNWEntity("VC_HookedVh")}  end  return {APos = APos, APVD = APVD, Fltr = Fltr} end  local function View_Handle_TP_Dyn(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View, Fltr, APos, APVD)  if VC.Settings.ThirdPerson_Dynamic then  if VC.Settings.ThirdPerson_Ang_Stf < 100 then  local TAng = LerpAngle(math.Clamp(VC.Settings.ThirdPerson_Ang_Stf*0.005*VC.FTm(),0,1), ((ply.VC_CCAng or Veh:GetAngles())- Veh:GetAngles())*(VC.Settings.ThirdPerson_Switch and -1 or 1)+ ply:EyeAngles(), (ply.VC_View_Angle_Real or ply:EyeAngles()))  ply:SetEyeAngles(Angle(VC.Settings.ThirdPerson_Wobbling and TAng.p or ply:EyeAngles().p, TAng.y, math.Clamp(Veh:GetVelocity():Dot(Veh:GetForward())/50* (VC.Settings.ThirdPerson_Sway_Reversed and -1 or 1), -15, 15)))  ply.VC_CCAng = Veh:GetAngles()  ply.VC_View_Angle_Simulated = ply:EyeAngles()  elseif ply.VC_CCAng then  ply:SetEyeAngles(ply.VC_View_Angle_Real or ply:EyeAngles())  ply.VC_CCAng = nil  end  if !ply.VC_ThrdP then ply.VC_TPVDC = APVD*1.03 ply.VC_ThrdP = true elseif ply.VC_ThrdP and !IsThirdPerson then ply.VC_ThrdP = false end  else  if ply.VC_CCAng then ply:SetEyeAngles(ply.VC_View_Angle_Real or ply:EyeAngles()) ply.VC_CCAng = nil end ply.VC_CnstVV = nil  end   if VC.Settings.ThirdPerson_Type == 1 then  local VelMeasure = (Veh:GetVelocity()-(VC.View_TP_LastVelMeasure or Veh:GetVelocity()))  VC.View_TP_LastVel = LerpVector(0.15, VC.View_TP_LastVel or VelMeasure, VelMeasure)  VC.View_TP_LastVelMeasure = Veh:GetVelocity() VC.View_TP_LastVel_Lerp = LerpVector(0.2, VC.View_TP_LastVel_Lerp or VC.View_TP_LastVel, VC.View_TP_LastVel)  APos = APos+VC.View_TP_LastVel_Lerp ply.VC_CnstVV = APos  elseif VC.Settings.ThirdPerson_Type == 2 then  APos = LerpVector(math.Clamp(VC.Settings.ThirdPerson_Vec_Stf*0.005*VC.FTm(),0,1), ply.VC_CnstVV or APos, APos)  if VC.Settings.ThirdPerson_Vec_Stf < 100 then ply.VC_CnstVV = APos else ply.VC_CnstVV = nil end  end   return {APos = APos, APVD = APVD, Fltr = Fltr} end  local function View_ThirdPerson(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View)  View = {}  local MMvd = VC.View_Handle_Mouse_Movement(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View)  View = VC.View_Handle_Auto(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View)    local Fltr, APos, APVD = Veh, Veh:LocalToWorld(Veh:OBBCenter())+ ang:Up(), Veh.VC_View_TP_Radius or 250   local HMlt = View_Handle_TP_Hight_Auto(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View, Fltr, APos, APVD)  APos = View_Handle_TP_Hight_Auto_Speed(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View, Fltr, APos, APVD, HMlt)   local Data = View_Handle_TP_Trailer(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View, Fltr, APos, APVD) Fltr = Data.Fltr APos = Data.APos APVD = Data.APVD   APVD = APVD*(ply.VC_TPVDM or 1)   local Data = View_Handle_TP_Dyn(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View, Fltr, APos, APVD) Fltr = Data.Fltr APos = Data.APos APVD = Data.APVD                       ply.VC_TPVDC = ply.VC_TPVDC or APVD if ply.VC_TPVDC > APVD+ 0.05 or ply.VC_TPVDC < APVD- 0.05 then ply.VC_TPVDC = Lerp(0.04*VC.FTm(), ply.VC_TPVDC, APVD) end  local TTTr = util.TraceLine({start = APos, endpos = APos+ ang:Forward()* -ply.VC_TPVDC, filter = Fltr, mask = MASK_NPCWORLDSTATIC})  View.origin = TTTr.HitPos+ TTTr.HitNormal* (3+ ply.VC_TPVDC/600)    return View end  local function View_Outside(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View)  return View end  function VC.HandleView(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov)  local View = nil local CursorVis = vgui.CursorVisible() local IsViewerSelf = VC.CheckViewerIsSelf()  if VSC then  if VC.Handle_View_Cinematic and IsViewerSelf and VC.Cinematic_View and (!ent.VC_IDSOVET or CurTime() >= ent.VC_IDSOVET) and !ply.VC_ExitingV then  View = VC.Handle_View_Cinematic(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov)  else  if ply.VC_Cin_CurMode then VC.CinModes[ply.VC_Cin_CurMode].End(ply, Veh) ply.VC_Cin_CurMode = nil ply.VC_Cin_ChangeTime = nil ply.VC_Cin_CurTime = nil end  local lastRanMode = VC.View_LastRanMode  if IsThirdPerson then  View = View_ThirdPerson(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View) VC.View_LastRanMode = "TP"  elseif IsViewerSelf then  View = {} View.origin = pos  if VC.View_FirstPerson then View = VC.View_FirstPerson(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View) end VC.View_LastRanMode = "FP"  else  View = View_Outside(IsThirdPerson, ply, ent, Veh, IsNotPod, VSC, pos, ang, fov, CursorVis, View) VC.View_LastRanMode = "Other"  end  if lastRanMode and lastRanMode != VC.View_LastRanMode then VC.ViewChanged() end  end  end  return View end  hook.Add("ShouldDrawLocalPlayer", "VC_ShouldDrawLocalPlayer", function(ply)  if VC.Settings.Enabled then  local ent = ply:GetVehicle()  if IsValid(ent) and (ent.VC_IsNotPrisonerPod or IsValid(!ent:GetParent()) or ent.VC_ExtraSeat or ent:GetNWBool("VC_HasWeapon")) and (VC.CheckIsThirdPerson(ent) or VCMod2) then return true end  end end) local rs7 = "vc.check_msg_work_ALS_k4" 